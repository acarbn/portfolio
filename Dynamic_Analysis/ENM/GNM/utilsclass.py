# -*- coding: utf-8 -*-
"""utilsclass.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Xd2nwEQqSmbiFE1u9M9lzAHBPqnPMk1h
"""

import numpy as np
import pandas as pd
from Bio.PDB import PDBParser, PDBList
from math import log, exp
import plotly.graph_objects as go
import os
from contextlib import redirect_stdout

class GNM:
    def __init__(self, fname1, mode_set, chainID,rcut_gnm):
        self.fname1 = fname1
        self.mode_set = mode_set  # list of specific modes, e.g., [2, 4, 5]
        self.chainID = chainID    # list of chains to include, e.g., ['A']
        self.rcut_gnm = rcut_gnm
        self.eigvals = None
        self.eigvecs = None
        self.residue_ids = None
        self.n_res=None
        self.MSF_avg=None

    def eigens(self):
        gamma = 1.0  # spring constant

        # Read PDB file
        parser = PDBParser(QUIET=True)
        try:
            pdbl = PDBList()
            with redirect_stdout(open(os.devnull, 'w')):
                pdbl.retrieve_pdb_file(self.fname1, pdir='.', file_format='pdb')
                structure = parser.get_structure('protein', f"pdb{self.fname1.lower()}.ent")
        except:
            print("PDB file not found")
            return

        coords = []
        residue_ids = []
        residue_counter = 0
        chain_start_end = {}  # To store the residue range for each chain

        chain=self.chainID
        for model in structure:
            for chain in model:
                if chain.get_id() in self.chainID:
                    chain_start_end[chain.get_id()] = (residue_counter, None)
                    for residue in chain:
                        if 'CA' in residue:
                            atom = residue['CA']
                            if atom.altloc in ('A', ' ') or atom.altloc == '':
                                coords.append(atom.coord)
                                hetflag, resseq, icode = residue.get_id()
                                res_str = f"{resseq}{icode.strip() or ''}"
                                residue_ids.append(res_str)
                                residue_counter += 1
                    chain_start_end[chain.get_id()] = (chain_start_end[chain.get_id()][0], residue_counter)
        self.chain_start_end=chain_start_end
        coords = np.array(coords)
        self.residue_ids = residue_ids
        self.n_res = len(coords)

        # Kirchhoff matrix
        K = np.zeros((self.n_res, self.n_res))
        for i in range(self.n_res):
            for j in range(i+1, self.n_res):
                d = np.linalg.norm(coords[i] - coords[j])
                if 0.0001 < d <= self.rcut_gnm:
                    K[i, j] = K[j, i] = -gamma
        np.fill_diagonal(K, -K.sum(axis=1))

        eigvals, eigvecs = np.linalg.eigh(K)
        nonzero = eigvals > 1e-6
        self.eigvals = eigvals[nonzero]
        self.eigvecs = eigvecs[:, nonzero]
        return self.eigvals, self.eigvecs

    def plot_eigens(self):
        fig = go.Figure()
        fig.add_trace(go.Scatter(
          x=self.mode_set,
          y=[self.eigvals[mode - 1] for mode in self.mode_set],
          mode='lines+markers',  # Combine both lines and markers
          line=dict(color='black', width=3),  # Line styling
          marker=dict(color='black', size=6)  # Marker styling (adjust size as needed)
          ))
        fig.update_layout(
          width=500,
          height=500,
          xaxis_title='Mode Number',
          yaxis_title='Eigenvalue',
          font=dict(size=14),
          margin=dict(l=40, r=40, t=40, b=40),
          )
        fig.show()

    def msf(self):
        if self.eigvals is None or self.eigvecs is None:
            raise ValueError("Run eigens() first to compute modes.")

        # If mode_set is a list of specific modes, e.g., [2, 4, 5]

        MSF_all = np.zeros((self.n_res, len(self.mode_set)))

        for idx, mode_num in enumerate(self.mode_set):
          k = mode_num - 1
          MSF_all[:, idx] = (self.eigvecs[:, k]**2) / self.eigvals[k]

          # mean over modes and normalize
        MSF_avg = MSF_all.mean(axis=1)
        MSF_avg /= np.trapz(MSF_avg)

        # Build DataFrame
        df = pd.DataFrame({
            'ResidueNo': self.residue_ids,
            'MSF': MSF_avg
        })
        self.MSF_avg=MSF_avg
        return df

    def plot_msf(self):
        fig2 = go.Figure()
        fig2.add_trace(go.Scatter(
          x=list(range(self.n_res)),
          y=self.MSF_avg,
          mode='lines',
          line=dict(color='black', width=3)
        ))

        # Add vertical lines for each chain's separation
        for self.chainID, (start, end) in self.chain_start_end.items():
          if end is not None:
            fig2.add_shape(
                type="line",
                x0=end, y0=0, x1=end, y1=max(self.MSF_avg),
                line=dict(color="red", width=2, dash="dash")
            )

        # Adjust layout for MSF plot
        fig2.update_layout(
          width=800,
          height=800,
          xaxis_title='Residue Number',
          yaxis_title='MSF',
          font=dict(size=14),
          margin=dict(l=40, r=40, t=40, b=40),
        )
        fig2.show()


    def mode_collectivity(self):
      if self.eigvals is None or self.eigvecs is None:
        raise ValueError("Run eigens() first to compute modes.")

      A = np.zeros(len(self.mode_set))
      alpha = np.zeros(len(self.mode_set))
      degcol = np.zeros(len(self.mode_set))

      for m, mode_num in enumerate(self.mode_set):
        kk = mode_num - 1
        A[m] = np.sum(self.eigvecs[:, kk] ** 2)
        alpha[m] = 1 / A[m]

        sumdeg = 0.0
        for i in range(self.n_res):
            val = alpha[m] * self.eigvecs[i, kk] ** 2
            if val > 0:  # to avoid log(0)
                sumdeg += val * log(val)

        degcol[m] = exp(-sumdeg) / self.n_res

      collectivity_df = pd.DataFrame({
        'Mode': self.mode_set,
        'Collectivity': degcol
      })

      return collectivity_df
