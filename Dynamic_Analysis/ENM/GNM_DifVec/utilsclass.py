# -*- coding: utf-8 -*-
"""utilsclass.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Xd2nwEQqSmbiFE1u9M9lzAHBPqnPMk1h
"""

import numpy as np
import py3Dmol
from io import StringIO
from google.colab import files
import pandas as pd
from Bio.PDB import PDBParser, PDBList,Superimposer, PDBIO
from math import log, exp
import plotly.graph_objects as go
import os
from contextlib import redirect_stdout

class GNM:
    def __init__(self, fname1, mode_set, chainID,rcut_gnm):
        self.fname1 = fname1
        self.mode_set = mode_set  # list of specific modes, e.g., [2, 4, 5]
        self.chainID = chainID    # list of chains to include, e.g., ['A']
        self.rcut_gnm = rcut_gnm
        self.eigvals = None
        self.eigvecs = None
        self.residue_ids = None
        self.n_res=None
        self.MSF_avg=None

    def eigens(self):
        gamma = 1.0  # spring constant

        # Read PDB file
        parser = PDBParser(QUIET=True)
        try:
            pdbl = PDBList()
            with redirect_stdout(open(os.devnull, 'w')):
                pdbl.retrieve_pdb_file(self.fname1, pdir='.', file_format='pdb')
                structure = parser.get_structure('protein', f"pdb{self.fname1.lower()}.ent")
        except:
            print("PDB file not found")
            return

        coords = []
        residue_ids = []
        residue_counter = 0
        chain_start_end = {}  # To store the residue range for each chain

        chain=self.chainID
        for model in structure:
            for chain in model:
                if chain.get_id() in self.chainID:
                    chain_start_end[chain.get_id()] = (residue_counter, None)
                    for residue in chain:
                        if 'CA' in residue:
                            atom = residue['CA']
                            if atom.altloc in ('A', ' ') or atom.altloc == '':
                                coords.append(atom.coord)
                                hetflag, resseq, icode = residue.get_id()
                                res_str = f"{resseq}{icode.strip() or ''}"
                                residue_ids.append(res_str)
                                residue_counter += 1
                    chain_start_end[chain.get_id()] = (chain_start_end[chain.get_id()][0], residue_counter)
        self.chain_start_end=chain_start_end
        coords = np.array(coords)
        self.residue_ids = residue_ids
        self.n_res = len(coords)

        # Kirchhoff matrix
        K = np.zeros((self.n_res, self.n_res))
        for i in range(self.n_res):
            for j in range(i+1, self.n_res):
                d = np.linalg.norm(coords[i] - coords[j])
                if 0.0001 < d <= self.rcut_gnm:
                    K[i, j] = K[j, i] = -gamma
        np.fill_diagonal(K, -K.sum(axis=1))

        eigvals, eigvecs = np.linalg.eigh(K)
        nonzero = eigvals > 1e-6
        self.eigvals = eigvals[nonzero]
        self.eigvecs = eigvecs[:, nonzero]
        return self.eigvals, self.eigvecs

    def plot_eigens(self):
        fig = go.Figure()
        fig.add_trace(go.Scatter(
          x=self.mode_set,
          y=[self.eigvals[mode - 1] for mode in self.mode_set],
          mode='lines+markers',  # Combine both lines and markers
          line=dict(color='black', width=3),  # Line styling
          marker=dict(color='black', size=6)  # Marker styling (adjust size as needed)
          ))
        fig.update_layout(
          width=500,
          height=500,
          xaxis_title='Mode Number',
          yaxis_title='Eigenvalue',
          font=dict(size=14),
          margin=dict(l=40, r=40, t=40, b=40),
          )
        fig.show()

    def msf(self):
        if self.eigvals is None or self.eigvecs is None:
            raise ValueError("Run eigens() first to compute modes.")

        # If mode_set is a list of specific modes, e.g., [2, 4, 5]

        MSF_all = np.zeros((self.n_res, len(self.mode_set)))

        for idx, mode_num in enumerate(self.mode_set):
          k = mode_num - 1
          MSF_all[:, idx] = (self.eigvecs[:, k]**2) / self.eigvals[k]

          # mean over modes and normalize
        MSF_avg = MSF_all.mean(axis=1)
        MSF_avg /= np.trapz(MSF_avg)

        # Build DataFrame
        df = pd.DataFrame({
            'ResidueNo': self.residue_ids,
            'MSF': MSF_avg
        })
        self.MSF_avg=MSF_avg
        return df

    def plot_msf(self):
        fig2 = go.Figure()
        fig2.add_trace(go.Scatter(
          x=list(range(self.n_res)),
          y=self.MSF_avg,
          mode='lines',
          line=dict(color='black', width=3)
        ))

        # Add vertical lines for each chain's separation
        for self.chainID, (start, end) in self.chain_start_end.items():
          if end is not None:
            fig2.add_shape(
                type="line",
                x0=end, y0=0, x1=end, y1=max(self.MSF_avg),
                line=dict(color="red", width=2, dash="dash")
            )

        # Adjust layout for MSF plot
        fig2.update_layout(
          width=800,
          height=800,
          xaxis_title='Residue Number',
          yaxis_title='MSF',
          font=dict(size=14),
          margin=dict(l=40, r=40, t=40, b=40),
        )
        fig2.show()


    def mode_collectivity(self):
      if self.eigvals is None or self.eigvecs is None:
        raise ValueError("Run eigens() first to compute modes.")

      A = np.zeros(len(self.mode_set))
      alpha = np.zeros(len(self.mode_set))
      degcol = np.zeros(len(self.mode_set))

      for m, mode_num in enumerate(self.mode_set):
        kk = mode_num - 1
        A[m] = np.sum(self.eigvecs[:, kk] ** 2)
        alpha[m] = 1 / A[m]

        sumdeg = 0.0
        for i in range(self.n_res):
            val = alpha[m] * self.eigvecs[i, kk] ** 2
            if val > 0:  # to avoid log(0)
                sumdeg += val * log(val)

        degcol[m] = exp(-sumdeg) / self.n_res

      collectivity_df = pd.DataFrame({
        'Mode': self.mode_set,
        'Collectivity': degcol
      })

      return collectivity_df

class StructureComparer:
    def __init__(self, PDBmobile, chainmobile, PDBref, chainref):
        self.PDBmobile = PDBmobile
        self.chainmobile = chainmobile  # String like "ABCD"
        self.PDBref = PDBref
        self.chainref = chainref        # String like "WXYZ"
        self.ref_atoms = []
        self.mov_atoms = []
        self.chain_len=[]
        self.mov_pdb = None
        self.ref_pdb = None
        self.ref_structure = None
        self.mov_structure = None
        self._diff_vector_computed = False
        self.diffs= []

    def parse_structures(self):
        pdbl = PDBList()
        ref_file = pdbl.retrieve_pdb_file(self.PDBref, pdir='.', file_format='pdb')
        mov_file = pdbl.retrieve_pdb_file(self.PDBmobile, pdir='.', file_format='pdb')

        parser = PDBParser(QUIET=True)
        self.ref_structure = parser.get_structure("ref", ref_file)
        self.mov_structure = parser.get_structure("mov", mov_file)
        print("Structures parsed.")

    def align_structures(self):
        # Convert chain IDs to lists
        ref_chains = list(self.chainref)
        mov_chains = list(self.chainmobile)

        if not self.ref_structure or not self.mov_structure:
            raise ValueError("Parse structures first.")

        # Validate chain counts match
        if len(ref_chains) != len(mov_chains):
            raise ValueError(f"Mismatched chain counts: Reference has {len(ref_chains)}, Mobile has {len(mov_chains)}")

        # Clear previous atom lists
        self.ref_atoms = []
        self.mov_atoms = []
        count=0
        # Process each chain pair
        for ref_id, mov_id in zip(ref_chains, mov_chains):
            try:
                ref_chain = self.ref_structure[0][ref_id]
                mov_chain = self.mov_structure[0][mov_id]
            except KeyError as e:
                raise ValueError(f"Chain {e} not found in structure") from e

            # Pair residues from corresponding positions
            for ref_res, mov_res in zip(ref_chain, mov_chain):
                if ref_res.has_id('CA') and mov_res.has_id('CA'):
                    count+=1
                    self.ref_atoms.append(ref_res['CA'])
                    self.mov_atoms.append(mov_res['CA'])
            self.chain_len.append(count)
        print("Ending positions of each chain: ",str(self.chain_len))
        if not self.ref_atoms or not self.mov_atoms:
            raise ValueError("No matching CA atoms found for alignment")

        # Perform superposition
        sup = Superimposer()
        sup.set_atoms(self.ref_atoms, self.mov_atoms)
        sup.apply(self.mov_structure.get_atoms())

        # Save aligned structures
        io = PDBIO()
        io.set_structure(self.mov_structure)
        with StringIO() as mov_aligned_str:
            io.save(mov_aligned_str)
            self.mov_pdb = mov_aligned_str.getvalue()

        io.set_structure(self.ref_structure)
        with StringIO() as ref_str:
            io.save(ref_str)
            self.ref_pdb = ref_str.getvalue()

    def visualize(self):
      view = py3Dmol.view(width=800, height=600)

      # Add reference model (blue)
      view.addModelsAsFrames(self.ref_pdb, 'pdb')
      view.setStyle({'model': 0}, {})  # Clear default styles
      for chain_id in self.chainref:
        view.setStyle({'model': 0, 'chain': chain_id}, {'cartoon': {'color': 'blue'}})

      # Add mobile model (red)
      view.addModelsAsFrames(self.mov_pdb, 'pdb')
      view.setStyle({'model': 1}, {})  # Clear default styles
      for chain_id in self.chainmobile:
        view.setStyle({'model': 1, 'chain': chain_id}, {'cartoon': {'color': 'red'}})

      view.zoomTo()
      return view


    def save_aligned_structures(self):
        with open(f"{self.PDBmobile}_aligned.pdb", 'w') as f:
            f.write(self.mov_pdb)
        with open(f"{self.PDBref}_ref.pdb", 'w') as f:
            f.write(self.ref_pdb)
        print("Files saved.")
        files.download(f"{self.PDBmobile}_aligned.pdb")
        files.download(f"{self.PDBref}_ref.pdb")
        print("Files downloaded.")

    def diff_vector(self):
        if not self.ref_atoms or not self.mov_atoms:
            raise ValueError("Align structures first")

        self.diffs = [(ref_atom.get_parent().id[1],
              float(np.linalg.norm(ref_atom.coord - mov_atom.coord)))
             for ref_atom, mov_atom in zip(self.ref_atoms, self.mov_atoms)]
        if not self._diff_vector_computed:
            print("Difference vector calculated for",len(self.diffs), "residues.")
            self._diff_vector_computed = True
        return self.diffs

    def plot_diff_vector(self,window):
        if self.diffs==[]:
          print("Difference vector not calculated. Would you like to compute it now? (y/n)")
          user_input = input().strip().lower()
          if user_input == 'y':
            # Compute the difference vector
            diff_vector = self.diff_vector()
          else:
            # Exit or break if no
            print("Exiting without calculation.")
            return  # or break depending on where this function is called
        else:
          diff_vector = self.diffs

        res_ids, distances = zip(*diff_vector)
        fig = go.Figure(data=go.Scatter(x=list(range(1,len(res_ids))), y=distances, mode='lines'))
        fig.update_layout(title='Residue Differences',
                          xaxis_title='Residue ID',
                          yaxis_title='Distance')

            # Customizing x-axis ticks
        new_tickvalslist = [] # X-axis tick positions (based on residue IDs)
        new_ticktextlist = []  # Custom labels for each tick

        # Calculate differences
        self.chain_len.insert(0, 0)

        for i in range(len(self.chain_len)):
          if i != 0:
            new_tickvals=list(range(self.chain_len[i-1]+window, self.chain_len[i], window))
            new_ticktext=list(range(window, self.chain_len[i]-self.chain_len[i-1], window))
            new_tickvalslist+=new_tickvals
            new_ticktextlist+=new_ticktext


        fig.update_layout(
          title='Residue Differences',
          xaxis_title='Residue ID',
          yaxis_title='Distance',
          xaxis=dict(
            tickvals=new_tickvalslist,   # Define the tick positions
            ticktext=new_ticktextlist    # Define the custom labels for ticks
          )
          )

        for idx in self.chain_len[1:-1]:  # skip the first, it's the start of the first chain
          fig.add_shape(
            type="line",
            x0=idx,
            y0=0,
            x1=idx,
            y1=max(distances),
            line=dict(color="red", width=1, dash="dash")
          )
        fig.show()

